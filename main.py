import numpy as np
import datetime as dt
import matplotlib.pyplot as plt
import csv
import re

_WEEK_DAYS = ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi", "Dimanche"]

class time_selector:
    """
    container class that stores functions of type
    func(datetime_obj: datetime.datetime) -> any
    """
    @staticmethod
    def day(datetime_obj):
        return datetime_obj.date()

    @staticmethod
    def week_day(datetime_obj):
        return datetime_obj.weekday()

    @staticmethod
    def hour(datetime_obj):
        return datetime_obj.hour

    @staticmethod
    def datetime(*dates):
        """return a function that assigns an index based on datetime delimiters
        all delimiters must have the same type {date, time, datetime}
        Parameters
        ----------
            dates : datetime.date or datetime.time or datetime.datetime
                datetime obj that delimit the groups.
        Returns
        ----------
            a function delimiter_selector(datetime_obj: datetime.datetime) -> any
        Pseudo example:
        ----------
        if dates = [yesterday, last week], the returned delimiter will assign one of 3 indices
        0 : all dates before and including last week
        1 : all dates strictly after last week but up to yesterday
        2 : all dates strictly after
        """
        dates = list(dates)
        dates.sort()

        if type(dates[0]) == dt.datetime:
            desired_property = lambda d: d
        elif type(dates[0]) == dt.date:
            desired_property = lambda d: d.date()
        elif type(dates[0]) == dt.time:
            desired_property = lambda d: d.time()
        else:
            raise TypeError("delimiter is not of type datetime.datetime, datetime.date or datetime.time")
    
        def delimiter_selector(datetime_obj):
            for i, date in enumerate(dates):
                if desired_property(datetime_obj) <= date:
                    return i
            return i + 1

        return delimiter_selector

    @staticmethod
    def combine(*selectors):
        """returns a function that's a combination of multiple selectors"""
        def combined_selector(datetime_obj):
            return tuple(selector(datetime_obj) for selector in selectors)
        return combined_selector

def less_than_ten_is_five(s):
    """ returns 
    Parameters
    ----------
        s : str
    Returns
    ----------
        the number of percents, or 5 when <10
    """
    if "<" in s:
        return 5
    else:
        return int(re.search("[0-9]+", s).group(0))

def import_data(path, delimiter=" ", date_time_fmt="%Y-%m-%d %H:%M:%S", percent_fmt=less_than_ten_is_five):
    """imports the data. Assumes that date and time are sperate columns to be merged together with a space.
    Parameters
    ----------
        path : str
            path to the data file
        delimiter : str
            character used to split the rows
        date_time_fmt : str
            exact format of date
        percent_fmt : func(s: str) -> int
            function that returns an int based on the string s

    Returns
    ----------
        time_stamps : list
        percent : list
    """
    time_stamps = []
    percent = []

    with open(path) as data_file:
        reader = csv.reader(data_file, delimiter=delimiter)
        for row in reader:
            if len(row) > 2:
                date_time_str = " ".join(row[:2]).split(".")[0] # ignore milliseconds
                percent_str = " ".join(row[2:])
                
                time_stamps.append(dt.datetime.strptime(date_time_str, date_time_fmt))
                percent.append(percent_fmt(percent_str))
                
    return time_stamps, percent

def grouped_mean(time_stamps, values, grouping_func=time_selector.day):
    """computes a mean percentage per specified group
    Parameters
    ----------
        time_stamps : list of datetime objects
        values : list of numbers matched to time_stamps
        grouping_func : func(datetime_obj: datetime.datetime) -> any
    Returns
    ----------
        keys : list of any
            keys generated by the grouping_func
        values : list of floats
            mean of each group corresponding to keys
    """
    out = {}

    # First group the values
    for t, v in zip(time_stamps, values):
        key = grouping_func(t)
        if key not in out:
            out[key] = []
        out[key].append(v)

    keys = []
    values = []

    # then compute mean in each group
    for key, val in out.items():
        keys.append(key)
        values.append(np.mean(val))

    return keys, values



if __name__ == "__main__":
    time_stamps, percents = import_data("Fribourg.txt")

    _, perc = grouped_mean(time_stamps, percents, time_selector.combine(time_selector.datetime(dt.time(12, 0)), time_selector.datetime(dt.time(18, 0))))
    print(f"Occupation moyenne avant midi : {perc[0]:.0f}%")
    print(f"Occupation moyenne entre midi et 18h : {perc[1]:.0f}%")
    print(f"Occupation moyenne après 18h : {perc[2]:.0f}%")

    weekday_hours, weekday_perc = grouped_mean(time_stamps, percents, time_selector.combine(time_selector.week_day, time_selector.hour))
    global_hours, global_perc = grouped_mean(time_stamps, percents, time_selector.hour)

    global_perc = np.array(global_perc)[np.argsort(global_hours)]
    global_hours.sort()


    weekdays = {} # reorganize in {weekday: [hour, mean_percent]} dictionary
    for key, val in zip(weekday_hours, weekday_perc):

        if key[0] not in weekdays:
            weekdays[key[0]] = [[],[]]
        weekdays[key[0]][0].append(key[1])
        weekdays[key[0]][1].append(val)
    
    fig, ax = plt.subplots()

    for key, val in weekdays.items():
        val = np.array(val)
        val[1] = val[1][np.argsort(val[0])]
        val[0].sort()
        ax.plot(val[0], val[1], label=_WEEK_DAYS[key])

    ax.plot(global_hours, global_perc, label="global")
    ax.set_xlim(9, 23)
    ax.set_xlabel("heure de la journée")
    ax.set_ylabel("pourcentage d'occupation")
    ax.legend()
    plt.show()